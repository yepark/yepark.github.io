---
layout: single
title: "[iOS] Core Data 사용법"
date: 2021-04-23
comments: true
categories:
  - ios
tags: [iOS, Objective-C]
# 목차
toc: true
toc_sticky: false
toc_label: "목차"
---

## Core Data 사용법

### iOS에서 데이터 핸들링..
Core Data는 데이터를 많이 다룰일이 없어서 쓸일이 없었다. 이번에 한번 써보자 생각하고 좀 찾아보니 괜찮은것 같아서 정리 해볼려고 한다.  
일반적으로 클라이언트에서 데이터를 저장할때 파일로 저장하거나 SQLite 같은 라이브러리를 사용한다. 저장할 데이터가 별로 없는 경우에 나같은 경우는 NSUserDefaults를 사용했다. NSUserDefaults는 설정 정보등을 저장할때 많이 사용한다. 또한, 중요 데이터의 경우 키체인을 사용해서 데이터를 저장했다. 사용자의 데이터 정보는 서버에서 받아오는 경우가 대부분이기 때문에 지금까지는 문제가 없었다...  

### Core Data?
보통 클라이언트에서 데이터를 다룰때 SQLite를 쓰는데, 이걸 사용하려면 라이브러리 관리도 해줘야 하고.. 쿼리문도 만들어서 써야한다. 이걸 쉽게 해주는게 Core Data라고 생각하면 된다.
단순히 데이터 저장 때문이면.. Core Data를 써야하겠다는 생각이 들지는 않았을것 같다. 내가 Core Data를 써야겠다고 느낀 이유는 프로젝트를 하다보면 모듈의 구조 및 클래스간의 관계.. 그리고 어떻게 하면 유연하게 코드를 짤까를 항상 고민하게 되는데.. 프로젝트의 모델 클래스들을 이 Core Data를 통하여 휘발성으로 관리 할수 있겠다고 생각이 들어서이다. Core Data는 자바를 해보신 분들은 JPA같은 ORM이라고 생각하면 된다.

Core Data는 Persistence를 이용하여 단순하게 데이터를 저장하지 않고(**NSInmemoryStoreType**) 사용하거나 영구적으로 저장해서(**NSSQLiteStoreType**) 사용할수 있다.(이외에도 있으나 잘 사용안함)

### 사용법
프로젝트 생성시에 Use Core Data를 체크하면 AppDelegate에 아래와 같은 소스가 생성 된다.
```swift
#pragma mark - Core Data stack

@synthesize persistentContainer = _persistentContainer;

- (NSPersistentContainer *)persistentContainer {
    // The persistent container for the application. This implementation creates and returns a container, having loaded the store for the application to it.
    @synchronized (self) {
        if (_persistentContainer == nil) {
            _persistentContainer = [[NSPersistentContainer alloc] initWithName:@"CoreDataTest"];
            [_persistentContainer loadPersistentStoresWithCompletionHandler:^(NSPersistentStoreDescription *storeDescription, NSError *error) {
                if (error != nil) {
                    // Replace this implementation with code to handle the error appropriately.
                    // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                    
                    /*
                     Typical reasons for an error here include:
                     * The parent directory does not exist, cannot be created, or disallows writing.
                     * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                     * The device is out of space.
                     * The store could not be migrated to the current model version.
                     Check the error message to determine what the actual problem was.
                    */
                    NSLog(@"Unresolved error %@, %@", error, error.userInfo);
                    abort();
                }
            }];
        }
    }
    
    return _persistentContainer;
}

#pragma mark - Core Data Saving support

- (void)saveContext {
    NSManagedObjectContext *context = self.persistentContainer.viewContext;
    NSError *error = nil;
    if ([context hasChanges] && ![context save:&error]) {
        // Replace this implementation with code to handle the error appropriately.
        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
        NSLog(@"Unresolved error %@, %@", error, error.userInfo);
        abort();
    }
}
```  
생성된 소스를 Core Data를 써야하는 곳에 매니저 클래스등으로 만들어서 사용한다.

파일중에 *.xcdatamodeld가 생성되어 있는데 이 파일에서 entity에 대한 정보를 기입한다.

entity를 추가하고 데이타 클래스의 이름으로 entity명을 정한다. 인스펙터에 Codegen - ClassDefinition으로 지정이 되면 자동으로 entitiy명으로 클래스가 생성된다. 
attribute에는 객체의 프로퍼티 멤버명을 정해주고 타입도 지정해준다. Transient으로 프로퍼티 속성을 체크할 경우 데이터는 저장되지 않는다.
어느정도 객체에 대한 설정이 끝났으면 XCode메뉴 Editor에 CreateNSManagedObject Subclass를 선택하면 클래스에 대한 카테고리 파일이 자동 생성된다.

저장 타입 변경
```
NSPersistentStoreCoordinator *psc = [[self managedObjectContext] persistentStoreCoordinator];
NSURL *oldURL = <#URL identifying the location of the current store#>;
NSURL *newURL = <#URL identifying the location of the new store#>;
NSError *error = nil;
NSPersistentStore *xmlStore = [psc persistentStoreForURL:oldURL];
NSPersistentStore *sqLiteStore = [psc migratePersistentStore:xmlStore
    toURL:newURL
    options:nil
    withType:NSSQLiteStoreType
    error:&error];
```

데이터 저장
```
AAAEmployeeMO *employee = [NSEntityDescription insertNewObjectForEntityForName:@"Employee" inManagedObjectContext:[self managedObjectContext];
employee.testData = @"데이터"; // 저장할 데이터 셋팅

NSError *error = nil;
if ([[self managedObjectContext] save:&error] == NO) {
    NSAssert(NO, @"Error saving context: %@\n%@", [error localizedDescription], [error userInfo]);
}
```

데이터 읽기
```
NSManagedObjectContext *moc = …;
NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Employee"];
 
NSError *error = nil;
NSArray *results = [moc executeFetchRequest:request error:&error];
if (!results) {
    NSLog(@"Error fetching Employee objects: %@\n%@", [error localizedDescription], [error userInfo]);
    abort();
}
```

```swift

#import <CoreData/CoreData.h>

typedef NS_ENUM(NSUInteger, CoreDataStoreType) {
    InMemoryStoreType = 0,
    SQLiteStoreType = 1
};

@interface CoreDataStackHandler : NSObject
+(instancetype)sharedInstance;
@property CoreDataStoreType storeType;
@property (readonly, strong) NSPersistentContainer *persistentContainer;
- (NSArray*)fetch:(NSString*)entityName;
- (void)deleteObject:(NSManagedObject*)object;
- (NSManagedObject*)newEntityObject:(NSString*)entityName;
- (void)saveContext;
@end

//////////////////////////////////////////////////////////////////////////
@implementation CoreDataStackHandler
@synthesize persistentContainer = _persistentContainer;
+(instancetype)sharedInstance {
    static CoreDataStackHandler *shared = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        shared = [[CoreDataStackHandler alloc] init];
        shared.storeType = SQLiteStoreType;
    });

    return shared;
}

- (NSPersistentContainer *)persistentContainer {
    // The persistent container for the application. This implementation creates and returns a container, having loaded the store for the application to it.
    @synchronized (self) {
        if (_persistentContainer == nil) {

            NSBundle *bundle = [NSBundle bundleWithIdentifier:@"com.yep.xxx"];  // 프레임워크일때..
            NSURL *url = [bundle URLForResource:@"DataModel파일명" withExtension:@"momd"];
            NSManagedObjectModel *manageObjectModel = [[NSManagedObjectModel alloc]initWithContentsOfURL:url];
            _persistentContainer = [[NSPersistentContainer alloc]initWithName:@"DataModel" managedObjectModel:manageObjectModel];
            if(self.storeType == InMemoryStoreType){
                NSPersistentStoreDescription *description = [[NSPersistentStoreDescription alloc]init];
                description.type = NSInMemoryStoreType;
                _persistentContainer.persistentStoreDescriptions = @[description];
            }
            
            [_persistentContainer loadPersistentStoresWithCompletionHandler:^(NSPersistentStoreDescription *storeDescription, NSError *error) {
                if (error != nil) {
                    // Replace this implementation with code to handle the error appropriately.
                    // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                    
                    /*
                     Typical reasons for an error here include:
                     * The parent directory does not exist, cannot be created, or disallows writing.
                     * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                     * The device is out of space.
                     * The store could not be migrated to the current model version.
                     Check the error message to determine what the actual problem was.
                    */
                    NSLog(@"Unresolved error %@, %@", error, error.userInfo);
                    abort();
                }
            }];
        }
    }
    return _persistentContainer;
}


- (NSArray*)fetch:(NSString*)entityName {
    NSFetchRequest* request = [NSFetchRequest fetchRequestWithEntityName:entityName];
    [request setReturnsObjectsAsFaults:FALSE];
    
    NSError *error = nil;
    NSArray *results = [self.persistentContainer.viewContext executeFetchRequest:request error:&error];
    if (!results) {
        NSLog(@"Error fetching %@ objects: %@\n%@", entitiName, [error localizedDescription], [error userInfo]);
        abort();
    }
    return results;
}
-(void)deleteObject:(NSManagedObject*)object {
    [self.persistentContainer.viewContext deleteObject:object];
}
- (NSManagedObject*)newEntityObject:(NSString*)entityName {
    return [NSEntityDescription insertNewObjectForEntityForName:entityName inManagedObjectContext:self.persistentContainer.viewContext];
}
- (void)saveContext {
    NSManagedObjectContext *context = self.persistentContainer.viewContext;
    NSError *error = nil;
    if ([context hasChanges] && ![context save:&error]) {
        // Replace this implementation with code to handle the error appropriately.
        // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
        NSLog(@"Unresolved error %@, %@", error, error.userInfo);
        abort();
    }
}
@end
```
### 참고
- <https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075-CH2-SW1>
- <https://stackoverflow.com/questions/7504391/need-some-help-understanding-transient-properties-in-core-data>
